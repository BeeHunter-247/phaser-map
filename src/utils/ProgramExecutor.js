/**
 * ProgramExecutor - Th·ª±c thi ch∆∞∆°ng tr√¨nh robot t·ª´ Blockly JSON
 */
import { checkAndDisplayVictory } from "./VictoryConditions.js";
export class ProgramExecutor {
  constructor(scene) {
    this.scene = scene;
    this.program = null;
    this.currentStep = 0;
    this.isRunning = false;
    this.isPaused = false;
    this.executionSpeed = 1000; // ms between commands
    this.timer = null;
    this.functions = new Map(); // L∆∞u tr·ªØ c√°c h√†m ƒë√£ ƒë·ªãnh nghƒ©a
    this.variableContext = {}; // L∆∞u gi√° tr·ªã bi·∫øn hi·ªán t·∫°i
    this.usedStatements = new Set(); // L∆∞u tr·ªØ c√°c statement ƒë√£ s·ª≠ d·ª•ng
    // L∆∞u tr·ªØ ch∆∞∆°ng tr√¨nh g·ªëc (ch∆∞a parse) v√† th·ªëng k√™ block
    this.originalProgramData = null;
    this.totalRawBlocks = 0;
  }

  /**
   * Load v√† validate ch∆∞∆°ng tr√¨nh t·ª´ JSON
   * @param {Object} programData - Blockly JSON program
   * @returns {boolean} Success/failure
   */
  loadProgram(programData) {
    try {
      // Validate program structure
      if (
        !programData.version ||
        !programData.actions ||
        !Array.isArray(programData.actions)
      ) {
        throw new Error("Invalid program structure");
      }

      // Reset used statements khi load program m·ªõi
      this.usedStatements.clear();

      // L∆∞u ch∆∞∆°ng tr√¨nh g·ªëc v√† ƒë·∫øm t·ªïng s·ªë block raw tr∆∞·ªõc khi parse/flatten
      this.originalProgramData = JSON.parse(JSON.stringify(programData));
      this.totalRawBlocks = this.countRawBlocks(this.originalProgramData);

      // X·ª≠ l√Ω function definitions tr∆∞·ªõc
      this.functions.clear();
      if (programData.functions && Array.isArray(programData.functions)) {
        for (const func of programData.functions) {
          this.functions.set(func.name, {
            name: func.name,
            actions: this.parseActions(func.body || []),
            original: func,
          });
          console.log(`üîß Defined function: ${func.name}`);
        }
      }

      // Parse v√† validate actions
      const parsedActions = this.parseActions(programData.actions);

      this.program = {
        version: programData.version,
        programName: programData.programName || "unnamed",
        actions: parsedActions,
      };

      console.log(`üìã Program loaded: ${this.program.programName}`);
      console.log(`   Version: ${this.program.version}`);
      console.log(`   Actions: ${this.program.actions.length}`);
      console.log(`   Functions: ${this.functions.size}`);
      console.log(`   Raw blocks (pre-parse): ${this.totalRawBlocks}`);
      console.log(
        `üßÆ Star inputs preview -> statementNumber: ${
          this.scene?.mapModel?.victoryConditions?.statementNumber ??
          this.scene?.challengeConfig?.victory?.statementNumber ??
          this.scene?.challengeJson?.statementNumber ??
          0
        }, totalRawBlocks: ${this.totalRawBlocks}`
      );

      return true;
    } catch (error) {
      console.error("‚ùå Failed to load program:", error.message);
      return false;
    }
  }

  /**
   * ƒê·∫øm t·ªïng s·ªë block (lo·∫°i) trong JSON ch∆∞∆°ng tr√¨nh g·ªëc tr∆∞·ªõc khi parse
   * - T√≠nh t·∫•t c·∫£ action c√≥ tr∆∞·ªùng 'type' (vd: repeat, if, repeatRange, while, forward, collect, ...)
   * - Bao g·ªìm c·∫£ block b√™n trong body/then/else/elseIf v√† function body
   * - Kh√¥ng t√≠nh c√°c ƒë·ªëi t∆∞·ª£ng ƒëi·ªÅu ki·ªán (cond) nh∆∞ variableComparison/and/or l√† block ri√™ng
   * @param {Object} program - JSON ch∆∞∆°ng tr√¨nh g·ªëc
   * @returns {number} T·ªïng s·ªë block
   */
  countRawBlocks(program) {
    if (!program || typeof program !== "object") return 0;

    let total = 0;

    // ƒê·∫øm trong ph·∫ßn ƒë·ªãnh nghƒ©a h√†m n·∫øu c√≥
    if (Array.isArray(program.functions)) {
      for (const func of program.functions) {
        if (Array.isArray(func.body)) {
          total += this.countBlocksInActions(func.body);
        }
      }
    }

    // ƒê·∫øm trong actions ch√≠nh
    if (Array.isArray(program.actions)) {
      total += this.countBlocksInActions(program.actions);
    }

    return total;
  }

  /**
   * ƒê·∫øm block trong m·∫£ng actions (raw) ƒë·ªá quy theo c·∫•u tr√∫c
   * @param {Array} actions
   * @returns {number}
   */
  countBlocksInActions(actions) {
    if (!Array.isArray(actions)) return 0;
    let count = 0;

    for (const action of actions) {
      if (!action || typeof action !== "object") continue;
      if (action.type) {
        count += 1; // B·∫£n th√¢n block hi·ªán t·∫°i
      }

      // M·ªü r·ªông theo t·ª´ng lo·∫°i ƒë·ªÉ duy·ªát ph·∫ßn th√¢n
      // repeat: body
      if (action.type === "repeat" && Array.isArray(action.body)) {
        count += this.countBlocksInActions(action.body);
      }

      // repeatRange: body
      if (action.type === "repeatRange" && Array.isArray(action.body)) {
        count += this.countBlocksInActions(action.body);
      }

      // if: then, elseIf[].then, else
      if (action.type === "if") {
        if (Array.isArray(action.then)) {
          count += this.countBlocksInActions(action.then);
        }
        if (Array.isArray(action.elseIf)) {
          for (const clause of action.elseIf) {
            if (clause && Array.isArray(clause.then)) {
              count += this.countBlocksInActions(clause.then);
            }
          }
        }
        if (Array.isArray(action.else)) {
          count += this.countBlocksInActions(action.else);
        }
      }

      // while: body
      if (action.type === "while" && Array.isArray(action.body)) {
        count += this.countBlocksInActions(action.body);
      }
    }

    return count;
  }

  /**
   * Parse v√† validate actions
   * @param {Array} actions - Raw actions from JSON
   * @returns {Array} Parsed actions
   */
  parseActions(actions) {
    const parsedActions = [];

    for (let i = 0; i < actions.length; i++) {
      const action = actions[i];

      // H·ªó tr·ª£ l·ªánh l·∫∑p repeat b·∫±ng c√°ch ph·∫≥ng ho√° (flatten) th√¢n l·ªánh v√†o danh s√°ch actions
      if (action && action.type === "repeat") {
        // Track repeat statement usage
        this.usedStatements.add("repeat");

        const repeatCount = parseInt(action.count) || 1;
        const bodyRaw = Array.isArray(action.body) ? action.body : [];

        // ƒê·ªá quy parse ph·∫ßn th√¢n ƒë·ªÉ h·ªó tr·ª£ repeat l·ªìng nhau
        const parsedBody = this.parseActions(bodyRaw);

        console.log(
          `üîÅ Expanding repeat x${repeatCount} with ${parsedBody.length} action(s) in body`
        );

        for (let r = 0; r < repeatCount; r++) {
          for (let j = 0; j < parsedBody.length; j++) {
            // Push b·∫£n sao n√¥ng l√† ƒë·ªß v√¨ c√°c action l√† immutable objects ƒë∆°n gi·∫£n
            parsedActions.push({ ...parsedBody[j] });
          }
        }
        continue;
      }

      // H·ªó tr·ª£ l·ªánh l·∫∑p repeat v·ªõi c√∫ ph√°p "repeat(i from 1 to 5 by 1)"
      if (action && action.type === "repeatRange") {
        // Track repeatRange statement usage
        this.usedStatements.add("repeatRange");

        const variableName = action.variable || "i";
        const fromValue = parseInt(action.from) || 1;
        const toValue = parseInt(action.to) || 5;
        const stepValue = parseInt(action.step) || 1;
        const bodyRaw = Array.isArray(action.body) ? action.body : [];

        // ƒê·ªá quy parse ph·∫ßn th√¢n ƒë·ªÉ h·ªó tr·ª£ repeat l·ªìng nhau
        const parsedBody = this.parseActions(bodyRaw);

        console.log(
          `üîÑ Expanding repeatRange ${variableName} from ${fromValue} to ${toValue} by ${stepValue} with ${parsedBody.length} action(s) in body`
        );

        // T·∫°o v√≤ng l·∫∑p t·ª´ fromValue ƒë·∫øn toValue v·ªõi stepValue
        for (
          let currentValue = fromValue;
          currentValue <= toValue;
          currentValue += stepValue
        ) {
          // T·∫°o b·∫£n sao s√¢u c·ªßa parsedBody v√† thay th·∫ø bi·∫øn
          for (let j = 0; j < parsedBody.length; j++) {
            const actionCopy = JSON.parse(JSON.stringify(parsedBody[j]));

            // Thay th·∫ø bi·∫øn trong action n·∫øu c√≥
            this.replaceVariableInAction(
              actionCopy,
              variableName,
              currentValue
            );

            // Th√™m th√¥ng tin v·ªÅ gi√° tr·ªã bi·∫øn hi·ªán t·∫°i cho vi·ªác ƒë√°nh gi√° ƒëi·ªÅu ki·ªán
            if (
              actionCopy.type === "if" &&
              actionCopy.condition &&
              actionCopy.condition.type === "variableComparison"
            ) {
              actionCopy._currentVariableValue = {
                [variableName]: currentValue,
              };
            }

            // Debug log ƒë·ªÉ ki·ªÉm tra bi·∫øn ƒë√£ ƒë∆∞·ª£c thay th·∫ø
            if (actionCopy.type === "collect") {
              console.log(
                `üîß DEBUG: Action copy for i=${currentValue}:`,
                JSON.stringify(actionCopy)
              );
            }

            parsedActions.push(actionCopy);
          }
        }
        continue;
      }

      const parsedAction = this.parseAction(action, i);
      if (parsedAction) {
        parsedActions.push(parsedAction);
      }
    }

    return parsedActions;
  }

  /**
   * Thay th·∫ø bi·∫øn trong action
   * @param {Object} action - Action object
   * @param {string} variableName - T√™n bi·∫øn c·∫ßn thay th·∫ø
   * @param {number} value - Gi√° tr·ªã thay th·∫ø
   */
  replaceVariableInAction(action, variableName, value) {
    if (!action || typeof action !== "object") return;

    // Thay th·∫ø bi·∫øn trong t·∫•t c·∫£ c√°c thu·ªôc t√≠nh c·ªßa action
    for (const key in action) {
      if (action.hasOwnProperty(key)) {
        const propValue = action[key];

        if (typeof propValue === "string") {
          // Thay th·∫ø bi·∫øn trong string (v√≠ d·ª•: "move {{i}} steps" ho·∫∑c "{{i}}")
          const replaced = propValue.replace(
            new RegExp(`{{${variableName}}}`, "g"),
            value
          );

          // N·∫øu string ch·ªâ ch·ª©a bi·∫øn v√† s·ªë, chuy·ªÉn th√†nh number
          if (replaced.match(/^\d+$/)) {
            action[key] = parseInt(replaced);
          } else {
            action[key] = replaced;
          }
        } else if (
          typeof propValue === "number" &&
          propValue === variableName
        ) {
          // Thay th·∫ø bi·∫øn n·∫øu gi√° tr·ªã l√† t√™n bi·∫øn
          action[key] = value;
        } else if (typeof propValue === "object" && propValue !== null) {
          // ƒê·ªá quy thay th·∫ø trong object l·ªìng nhau
          this.replaceVariableInAction(propValue, variableName, value);
        }
      }
    }
  }

  /**
   * Parse m·ªôt action c·ª• th·ªÉ
   * @param {Object} action - Raw action
   * @param {number} index - Action index
   * @returns {Object|null} Parsed action or null if invalid
   */
  parseAction(action, index) {
    if (!action.type) {
      console.warn(`‚ö†Ô∏è Action ${index}: Missing type`);
      return null;
    }

    switch (action.type) {
      case "if": {
        // Gi·ªØ nguy√™n c·∫•u tr√∫c if ƒë·ªÉ ƒë√°nh gi√° ·ªü runtime, m·ªü r·ªông h·ªó tr·ª£ else-if v√† else
        const thenActions = Array.isArray(action.then)
          ? this.parseActions(action.then)
          : [];
        const condition = this.parseCondition(action.cond);

        // else-if: m·∫£ng c√°c object { cond, then }
        const rawElseIf = Array.isArray(action.elseIf) ? action.elseIf : [];
        const elseIfClauses = rawElseIf
          .map((clause) => {
            if (!clause || typeof clause !== "object") return null;
            const c = this.parseCondition(clause.cond);
            const a = Array.isArray(clause.then)
              ? this.parseActions(clause.then)
              : [];
            return { condition: c, thenActions: a };
          })
          .filter((x) => x !== null);

        // else: danh s√°ch actions
        const elseActions = Array.isArray(action.else)
          ? this.parseActions(action.else)
          : [];

        return {
          type: "if",
          condition,
          thenActions,
          elseIfClauses,
          elseActions,
          original: action,
        };
      }

      case "while": {
        // Gi·ªØ nguy√™n c·∫•u tr√∫c while ƒë·ªÉ ƒë√°nh gi√° ·ªü runtime
        const bodyActions = Array.isArray(action.body) ? action.body : [];
        const condition = this.parseCondition(action.cond);
        return {
          type: "while",
          condition,
          bodyActions,
          original: action,
        };
      }

      case "callFunction": {
        // G·ªçi h√†m ƒë√£ ƒë·ªãnh nghƒ©a
        return {
          type: "callFunction",
          functionName: action.functionName || action.name,
          original: action,
        };
      }

      case "forward":
        return {
          type: "forward",
          count: parseInt(action.count) || 1,
          original: action,
        };

      case "turnRight":
        return {
          type: "turnRight",
          original: action,
        };

      case "turnLeft":
        return {
          type: "turnLeft",
          original: action,
        };

      case "turnBack":
        return {
          type: "turnBack",
          original: action,
        };

      case "collect":
        return {
          type: "collect",
          count: action.count, // Kh√¥ng parse ngay, ƒë·ªÉ cho replaceVariableInAction x·ª≠ l√Ω
          colors: action.color ? [action.color] : ["green"],
          original: action,
        };

      case "putBox":
        return {
          type: "putBox",
          count: parseInt(action.count) || 1,
          original: action,
        };

      case "takeBox":
        return {
          type: "takeBox",
          count: parseInt(action.count) || 1,
          original: action,
        };

      default:
        console.warn(`‚ö†Ô∏è Action ${index}: Unknown type "${action.type}"`);
        return null;
    }
  }

  /**
   * Parse ƒë·ªëi t∆∞·ª£ng ƒëi·ªÅu ki·ªán
   * @param {Object} cond - Raw condition
   * @returns {Object|null}
   */
  parseCondition(cond) {
    if (!cond || typeof cond !== "object") return null;

    // ƒêi·ªÅu ki·ªán so s√°nh bi·∫øn: { type: "variableComparison", variable: "i", operator: "==", value: 0 }
    // H·ªó tr·ª£ c·∫£ bi·∫øn th∆∞·ªùng v√† bi·∫øn ƒë·∫∑c bi·ªát nh∆∞ "batteryCount", "greenCount", "redCount", "yellowCount"
    if (cond.type === "variableComparison") {
      return {
        type: "variableComparison",
        variable: cond.variable || "i",
        operator: cond.operator || "==",
        value: cond.value !== undefined ? cond.value : 0,
        original: cond,
      };
    }

    // H·ªó tr·ª£ c·∫£ 2 format: functionName v√† function
    // ƒêi·ªÅu ki·ªán logic AND: { type: "and", conditions: [cond1, cond2] }
    if (cond.type === "and") {
      return {
        type: "and",
        conditions: Array.isArray(cond.conditions)
          ? cond.conditions
              .map((c) => this.parseCondition(c))
              .filter((c) => c !== null)
          : [],
        original: cond,
      };
    }

    // ƒêi·ªÅu ki·ªán logic OR: { type: "or", conditions: [cond1, cond2] }
    if (cond.type === "or") {
      return {
        type: "or",
        conditions: Array.isArray(cond.conditions)
          ? cond.conditions
              .map((c) => this.parseCondition(c))
              .filter((c) => c !== null)
          : [],
        original: cond,
      };
    }

    // ƒêi·ªÅu ki·ªán c≈©: { type: "condition", function: "isGreen", check: true }
    return {
      type: cond.type || "condition",
      functionName: cond.functionName || cond.function || null,
      operator: cond.operator || null,
      value: cond.value || null,
      check: typeof cond.check === "boolean" ? cond.check : true,
      original: cond,
    };
  }

  /**
   * B·∫Øt ƒë·∫ßu th·ª±c thi ch∆∞∆°ng tr√¨nh
   */
  startProgram() {
    if (!this.program) {
      console.error("‚ùå No program loaded");
      return false;
    }

    if (this.isRunning) {
      console.warn("‚ö†Ô∏è Program already running");
      return false;
    }

    this.currentStep = 0;
    this.isRunning = true;
    this.isPaused = false;

    console.log(`üöÄ Starting program: ${this.program.programName}`);
    this.executeNextCommand();

    return true;
  }

  /**
   * D·ª´ng ch∆∞∆°ng tr√¨nh
   */
  stopProgram() {
    this.isRunning = false;
    this.isPaused = false;
    this.currentStep = 0;

    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }

    console.log("‚èπÔ∏è Program stopped");
  }

  /**
   * T·∫°m d·ª´ng ch∆∞∆°ng tr√¨nh
   */
  pauseProgram() {
    if (!this.isRunning) return;

    this.isPaused = true;
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }

    console.log("‚è∏Ô∏è Program paused");
  }

  /**
   * Ti·∫øp t·ª•c ch∆∞∆°ng tr√¨nh
   */
  resumeProgram() {
    if (!this.isRunning || !this.isPaused) return;

    this.isPaused = false;
    console.log("‚ñ∂Ô∏è Program resumed");
    this.executeNextCommand();
  }

  /**
   * Th·ª±c thi l·ªánh ti·∫øp theo
   */
  executeNextCommand() {
    if (!this.isRunning || this.isPaused) {
      console.log(
        `‚è∏Ô∏è Program paused or stopped. Current step: ${this.currentStep}`
      );
      return;
    }

    if (this.currentStep >= this.program.actions.length) {
      console.log("‚úÖ Program completed!");

      // KI·ªÇM TRA THUA KHI CH∆Ø∆†NG TR√åNH K·∫æT TH√öC
      const victoryResult = checkAndDisplayVictory(this.scene);
      if (!victoryResult.isVictory) {
        // Ch∆∞∆°ng tr√¨nh k·∫øt th√∫c nh∆∞ng ch∆∞a ƒë·ªß pin = THUA
        this.scene.lose("Ch∆∞∆°ng tr√¨nh k·∫øt th√∫c thua cu·ªôc!");
      } else {
        // G·ª≠i th√¥ng b√°o chi·∫øn th·∫Øng ra webview (kh√¥ng blocking)
        import("./WebViewMessenger.js")
          .then(({ sendVictoryMessage }) => {
            if (typeof sendVictoryMessage === "function") {
              const payload = {};
              if (typeof victoryResult?.starScore === "number") {
                payload.score = victoryResult.starScore;
              }
              sendVictoryMessage(payload);
            }
          })
          .catch((e) => console.warn("Cannot send victory message:", e));
      }

      this.stopProgram();
      return;
    }

    const action = this.program.actions[this.currentStep];
    console.log(
      `üéØ Executing step ${this.currentStep + 1}/${
        this.program.actions.length
      }: ${action.type}${action.count ? ` (count: ${action.count})` : ""}`
    );

    // Th·ª±c thi l·ªánh
    const success = this.executeCommand(action);

    if (success) {
      // Ch·ªâ tƒÉng step v√† ti·∫øp t·ª•c cho c√°c l·ªánh sync
      // C√°c l·ªánh async (nh∆∞ forward) s·∫Ω t·ª± g·ªçi executeNextCommand()
      if (action.type !== "forward") {
        this.currentStep++;
        // Ti·∫øp t·ª•c v·ªõi l·ªánh ti·∫øp theo sau delay
        this.timer = setTimeout(() => {
          this.executeNextCommand();
        }, this.executionSpeed);
      }
      // L·ªánh forward s·∫Ω t·ª± x·ª≠ l√Ω vi·ªác chuy·ªÉn sang l·ªánh ti·∫øp theo
    } else {
      console.error(`‚ùå Command failed at step ${this.currentStep + 1}`);
      this.stopProgram();
    }
  }

  /**
   * Th·ª±c thi m·ªôt l·ªánh c·ª• th·ªÉ
   * @param {Object} action - Action to execute
   * @returns {boolean} Success/failure
   */
  executeCommand(action) {
    try {
      // Track statement usage
      this.usedStatements.add(action.type);

      switch (action.type) {
        case "if":
          return this.executeIf(action);

        case "while":
          return this.executeWhile(action);

        case "callFunction":
          return this.executeCallFunction(action);

        case "forward":
          return this.executeForward(action.count);

        case "turnRight":
          return this.scene.turnRight();

        case "turnLeft":
          return this.scene.turnLeft();

        case "turnBack":
          return this.scene.turnBack();

        case "collect":
          return this.executeCollect(action.count, action.colors);

        case "putBox":
          return this.executePutBox(action.count);

        case "takeBox":
          return this.executeTakeBox(action.count);

        default:
          console.error(`‚ùå Unknown command: ${action.type}`);
          return false;
      }
    } catch (error) {
      console.error(`‚ùå Error executing command:`, error);
      return false;
    }
  }

  /**
   * Th·ª±c thi c√¢u l·ªánh if
   * - N·∫øu ƒëi·ªÅu ki·ªán ƒë√∫ng, ch√®n thenActions ngay sau b∆∞·ªõc hi·ªán t·∫°i
   */
  executeIf(action) {
    try {
      // L·∫•y context bi·∫øn t·ª´ action (n·∫øu c√≥)
      const variableContext = action._currentVariableValue || {};

      // Chu·ªói nh√°nh: IF ‚Üí (ELSE-IF)* ‚Üí ELSE
      const branches = [];

      // Nh√°nh IF ƒë·∫ßu ti√™n
      branches.push({
        condition: action.condition,
        actions: Array.isArray(action.thenActions) ? action.thenActions : [],
        label: "IF",
      });

      // C√°c nh√°nh ELSE-IF n·∫øu c√≥
      const elseIfs = Array.isArray(action.elseIfClauses)
        ? action.elseIfClauses
        : [];
      elseIfs.forEach((cl, idx) => {
        branches.push({
          condition: cl?.condition || null,
          actions: Array.isArray(cl?.thenActions) ? cl.thenActions : [],
          label: `ELSE-IF#${idx + 1}`,
        });
      });

      // ELSE actions n·∫øu c√≥
      const elseActions = Array.isArray(action.elseActions)
        ? action.elseActions
        : [];

      // T√¨m nh√°nh ph√π h·ª£p ƒë·∫ßu ti√™n
      let selectedActions = null;
      for (const br of branches) {
        const ok = this.evaluateCondition(br.condition, variableContext);
        console.log(
          `ü§î ${br.label} condition (${
            br.condition?.functionName || br.condition?.type
          }) => ${ok}`
        );
        if (ok) {
          selectedActions = br.actions;
          break;
        }
      }

      // N·∫øu kh√¥ng c√≥ nh√°nh n√†o kh·ªõp, d√πng ELSE
      if (!selectedActions || selectedActions.length === 0) {
        if (elseActions.length > 0) {
          selectedActions = elseActions;
          console.log(
            `üß© Using ELSE branch with ${elseActions.length} action(s)`
          );
        }
      }

      if (Array.isArray(selectedActions) && selectedActions.length > 0) {
        const insertIndex = this.currentStep + 1;
        this.program.actions.splice(
          insertIndex,
          0,
          ...selectedActions.map((a) => ({ ...a }))
        );
        console.log(
          `üß© Inserted ${selectedActions.length} action(s) at ${insertIndex}`
        );
      }
      return true;
    } catch (e) {
      console.error("‚ùå Failed to execute IF:", e);
      return false;
    }
  }

  /**
   * Th·ª±c thi c√¢u l·ªánh while
   * - N·∫øu ƒëi·ªÅu ki·ªán ƒë√∫ng, ch√®n bodyActions v√† t√°i ch√®n while ƒë·ªÉ l·∫∑p l·∫°i
   */
  executeWhile(action) {
    try {
      const result = this.evaluateCondition(action.condition);
      console.log(
        `üîÑ WHILE condition (${action.condition?.functionName}) => ${result}`
      );

      if (
        result &&
        Array.isArray(action.bodyActions) &&
        action.bodyActions.length > 0
      ) {
        // Ch√®n bodyActions v√† t√°i ch√®n while ƒë·ªÉ l·∫∑p l·∫°i
        const insertIndex = this.currentStep + 1;
        const whileAction = { ...action }; // T·∫°o b·∫£n sao c·ªßa while action
        this.program.actions.splice(
          insertIndex,
          0,
          ...action.bodyActions.map((a) => ({ ...a })),
          whileAction
        );
        console.log(
          `üîÑ Inserted ${action.bodyActions.length} body action(s) + while loop at ${insertIndex}`
        );
      }
      return true;
    } catch (e) {
      console.error("‚ùå Failed to execute WHILE:", e);
      return false;
    }
  }

  /**
   * Th·ª±c thi g·ªçi h√†m
   * - Ch√®n c√°c action c·ªßa h√†m v√†o v·ªã tr√≠ hi·ªán t·∫°i
   */
  executeCallFunction(action) {
    try {
      const functionName = action.functionName;
      const func = this.functions.get(functionName);

      if (!func) {
        console.error(`‚ùå Function '${functionName}' not found`);
        return false;
      }

      console.log(`üîß Calling function: ${functionName}`);

      if (Array.isArray(func.actions) && func.actions.length > 0) {
        // Ch√®n c√°c action c·ªßa h√†m v√†o v·ªã tr√≠ hi·ªán t·∫°i
        const insertIndex = this.currentStep + 1;
        this.program.actions.splice(
          insertIndex,
          0,
          ...func.actions.map((a) => ({ ...a }))
        );
        console.log(
          `üîß Inserted ${func.actions.length} action(s) from function '${functionName}' at ${insertIndex}`
        );
      }
      return true;
    } catch (e) {
      console.error("‚ùå Failed to execute function call:", e);
      return false;
    }
  }

  /**
   * ƒê√°nh gi√° ƒëi·ªÅu ki·ªán
   * H·ªó tr·ª£: condition.function = "isGreen" => c√≥ pin xanh t·∫°i √¥ hi·ªán t·∫°i?
   * H·ªó tr·ª£: variableComparison => so s√°nh bi·∫øn v·ªõi gi√° tr·ªã (bao g·ªìm bi·∫øn ƒë·∫∑c bi·ªát)
   * H·ªó tr·ª£: and/or => ƒëi·ªÅu ki·ªán logic
   * N·∫øu cond.check = false th√¨ ƒë·∫£o ng∆∞·ª£c k·∫øt qu·∫£
   */
  evaluateCondition(cond, variableContext = {}) {
    if (!cond) return false;

    // ƒêi·ªÅu ki·ªán so s√°nh bi·∫øn (bao g·ªìm bi·∫øn ƒë·∫∑c bi·ªát)
    if (cond.type === "variableComparison") {
      let variableValue = variableContext[cond.variable];

      // N·∫øu kh√¥ng t√¨m th·∫•y trong context, ki·ªÉm tra bi·∫øn ƒë·∫∑c bi·ªát
      if (variableValue === undefined) {
        variableValue = this.getSpecialVariableValue(cond.variable);
      }

      if (variableValue === undefined) {
        console.warn(
          `‚ö†Ô∏è Variable "${cond.variable}" not found in context or special variables`
        );
        return false;
      }

      const result = this.compareValues(
        variableValue,
        cond.operator,
        cond.value
      );
      console.log(
        `üîç Variable comparison: ${cond.variable}(${variableValue}) ${cond.operator} ${cond.value} => ${result}`
      );
      return result;
    }

    // ƒêi·ªÅu ki·ªán logic AND
    if (cond.type === "and") {
      if (!Array.isArray(cond.conditions) || cond.conditions.length === 0) {
        return false;
      }

      const results = cond.conditions.map((c) =>
        this.evaluateCondition(c, variableContext)
      );
      const result = results.every((r) => r === true);
      console.log(`üîó AND condition: [${results.join(", ")}] => ${result}`);
      return result;
    }

    // ƒêi·ªÅu ki·ªán logic OR
    if (cond.type === "or") {
      if (!Array.isArray(cond.conditions) || cond.conditions.length === 0) {
        return false;
      }

      const results = cond.conditions.map((c) =>
        this.evaluateCondition(c, variableContext)
      );
      const result = results.some((r) => r === true);
      console.log(`üîó OR condition: [${results.join(", ")}] => ${result}`);
      return result;
    }

    // ƒêi·ªÅu ki·ªán c≈© (sensor-based)
    let actual = false;
    const functionName = cond.functionName || cond.function;
    switch (functionName) {
      case "isGreen":
        actual = this.hasBatteryColorAtCurrentTile("green");
        break;
      case "warehouseCount":
        // Number box block - g·ªçi checkWarehouse() v√† so s√°nh v·ªõi gi√° tr·ªã
        const warehouseCount = this.scene.boxManager.checkWarehouse();
        const operator = cond.operator || "==";
        const compareValue = parseInt(cond.value) || 0;
        actual = this.compareValues(warehouseCount, operator, compareValue);
        break;
      case "isRed":
        actual = this.hasBatteryColorAtCurrentTile("red");
        break;
      case "isYellow":
        actual = this.hasBatteryColorAtCurrentTile("yellow");
        break;
      default:
        console.warn(`‚ö†Ô∏è Unknown condition function: ${functionName}`);
        actual = false;
    }
    return cond.check ? actual : !actual;
  }

  /**
   * So s√°nh hai gi√° tr·ªã v·ªõi to√°n t·ª≠
   * @param {*} leftValue - Gi√° tr·ªã b√™n tr√°i
   * @param {string} operator - To√°n t·ª≠ (==, !=, <, >, <=, >=)
   * @param {*} rightValue - Gi√° tr·ªã b√™n ph·∫£i
   * @returns {boolean}
   */
  compareValues(leftValue, operator, rightValue) {
    switch (operator) {
      case "==":
        return leftValue == rightValue;
      case "!=":
        return leftValue != rightValue;
      case "<":
        return leftValue < rightValue;
      case ">":
        return leftValue > rightValue;
      case "<=":
        return leftValue <= rightValue;
      case ">=":
        return leftValue >= rightValue;
      default:
        console.warn(`‚ö†Ô∏è Unknown operator: ${operator}`);
        return false;
    }
  }

  /**
   * Ki·ªÉm tra c√≥ pin m√†u ch·ªâ ƒë·ªãnh t·∫°i √¥ hi·ªán t·∫°i kh√¥ng
   */
  hasBatteryColorAtCurrentTile(color) {
    const info = this.scene.getBatteriesAtCurrentTile();
    if (!info) return false;
    const count = info?.count || 0;
    if (count <= 0) return false;
    const types = Array.isArray(info?.types) ? info.types : [];
    return types.some((t) => t === color);
  }

  /**
   * L·∫•y s·ªë l∆∞·ª£ng pin t·∫°i v·ªã tr√≠ hi·ªán t·∫°i
   * @returns {number} S·ªë l∆∞·ª£ng pin
   */
  getNumberBattery() {
    const info = this.scene.getBatteriesAtCurrentTile();
    if (!info) return 0;
    return info?.count || 0;
  }

  /**
   * L·∫•y gi√° tr·ªã c·ªßa bi·∫øn ƒë·∫∑c bi·ªát
   * @param {string} variableName - T√™n bi·∫øn ƒë·∫∑c bi·ªát
   * @returns {number|undefined} Gi√° tr·ªã bi·∫øn ho·∫∑c undefined n·∫øu kh√¥ng t√¨m th·∫•y
   */
  getSpecialVariableValue(variableName) {
    const info = this.scene.getBatteriesAtCurrentTile();
    if (!info) return undefined;

    switch (variableName) {
      case "batteryCount":
        return info?.count || 0;

      case "greenCount":
        return this.getBatteryCountByColor("green");

      case "redCount":
        return this.getBatteryCountByColor("red");

      case "yellowCount":
        return this.getBatteryCountByColor("yellow");

      default:
        return undefined;
    }
  }

  /**
   * ƒê·∫øm s·ªë l∆∞·ª£ng pin theo m√†u t·∫°i v·ªã tr√≠ hi·ªán t·∫°i
   * @param {string} color - M√†u pin c·∫ßn ƒë·∫øm
   * @returns {number} S·ªë l∆∞·ª£ng pin theo m√†u
   */
  getBatteryCountByColor(color) {
    const info = this.scene.getBatteriesAtCurrentTile();
    if (!info || !Array.isArray(info.types)) return 0;

    return info.types.filter((type) => type === color).length;
  }

  /**
   * Th·ª±c thi l·ªánh forward v·ªõi count
   * @param {number} count - S·ªë b∆∞·ªõc ƒëi
   * @returns {boolean} Success/failure
   */
  executeForward(count) {
    console.log(`üö∂ Moving forward ${count} step(s)`);

    // Th·ª±c hi·ªán t·ª´ng b∆∞·ªõc m·ªôt c√°ch tu·∫ßn t·ª±
    this.executeForwardStep(count, 0);
    return true; // Kh√¥ng g·ªçi executeNextCommand() ·ªü ƒë√¢y, ƒë·ªÉ executeForwardStep x·ª≠ l√Ω
  }

  /**
   * Th·ª±c thi m·ªôt b∆∞·ªõc forward
   * @param {number} totalCount - T·ªïng s·ªë b∆∞·ªõc
   * @param {number} currentStep - B∆∞·ªõc hi·ªán t·∫°i
   */
  executeForwardStep(totalCount, currentStep) {
    if (currentStep >= totalCount) {
      // Ho√†n th√†nh t·∫•t c·∫£ b∆∞·ªõc, tƒÉng step v√† ti·∫øp t·ª•c v·ªõi l·ªánh ti·∫øp theo
      this.currentStep++;
      this.executeNextCommand();
      return;
    }

    const success = this.scene.moveForward();
    if (!success) {
      console.error(
        `‚ùå Failed to move forward at step ${currentStep + 1}/${totalCount}`
      );
      this.stopProgram();
      return;
    }

    // Ch·ªù animation ho√†n th√†nh r·ªìi th·ª±c hi·ªán b∆∞·ªõc ti·∫øp theo
    setTimeout(() => {
      this.executeForwardStep(totalCount, currentStep + 1);
    }, 400); // Ch·ªù animation ho√†n th√†nh
  }

  /**
   * Th·ª±c thi l·ªánh collect v·ªõi count v√† colors
   * @param {number} count - S·ªë l·∫ßn collect
   * @param {Array} colors - M√†u s·∫Øc battery
   * @returns {boolean} Success/failure
   */
  executeCollect(count, colors) {
    // Parse count n·∫øu l√† string
    const parsedCount =
      typeof count === "string" ? parseInt(count) || 1 : count || 1;
    console.log(
      `üîã Collecting ${parsedCount} battery(ies) with colors:`,
      colors
    );

    // Pre-check: ƒë·ªß s·ªë l∆∞·ª£ng theo m√†u y√™u c·∫ßu?
    const {
      key,
      sprites,
      types,
      count: perTileCount,
    } = this.scene.getBatteriesAtCurrentTile();
    if (perTileCount === 0) {
      this.scene.lose("Kh√¥ng c√≥ pin t·∫°i √¥ hi·ªán t·∫°i");
      return false;
    }

    console.log(
      `üîç Collect pre-check at tile ${key}: available=${perTileCount}, requested=${parsedCount}`
    );

    // Quy t·∫Øc: s·ªë l∆∞·ª£ng ph·∫£i kh·ªõp CH√çNH X√ÅC v·ªõi s·ªë pin trong √¥
    if (perTileCount !== parsedCount) {
      this.scene.lose(
        `C√≥ ${perTileCount} pin t·∫°i √¥, nh∆∞ng y√™u c·∫ßu thu th·∫≠p ${parsedCount} (ph·∫£i kh·ªõp ch√≠nh x√°c)`
      );
      return false;
    }

    // Chu·∫©n h√≥a colors
    const normalizedColors =
      Array.isArray(colors) && colors.length > 0 ? colors : ["green"];

    // ƒê·∫øm theo m√†u hi·ªán c√≥
    const available = { red: 0, yellow: 0, green: 0 };
    types.forEach((t) => (available[t] = (available[t] || 0) + 1));

    // Ki·ªÉm tra theo m√†u y√™u c·∫ßu n·∫øu c√≥
    let requiredByColor = { red: 0, yellow: 0, green: 0 };
    for (let i = 0; i < parsedCount; i++) {
      const c =
        normalizedColors[i] ||
        normalizedColors[normalizedColors.length - 1] ||
        "green";
      requiredByColor[c] = (requiredByColor[c] || 0) + 1;
    }
    for (const c of Object.keys(requiredByColor)) {
      if ((available[c] || 0) < requiredByColor[c]) {
        this.scene.lose(
          `Kh√¥ng ƒë·ªß pin m√†u ${c}. C·∫ßn ${requiredByColor[c]}, c√≥ ${
            available[c] || 0
          }`
        );
        return false;
      }
    }

    // Th·ª±c hi·ªán nh·∫∑t
    for (let i = 0; i < parsedCount; i++) {
      const color =
        normalizedColors[i] ||
        normalizedColors[normalizedColors.length - 1] ||
        "green";
      console.log(`   Collecting ${color} battery (${i + 1}/${parsedCount})`);
      const ok = this.scene.collectBattery(color);
      if (!ok) return false;
    }

    return true;
  }

  /**
   * Th·ª±c thi l·ªánh putBox
   * @param {number} count - S·ªë l∆∞·ª£ng box c·∫ßn ƒë·∫∑t
   * @returns {boolean} Success/failure
   */
  executePutBox(count) {
    console.log(`üì¶ Putting ${count} box(es)`);

    try {
      const success = this.scene.putBox(count);
      if (!success) {
        console.error(`‚ùå Failed to put ${count} box(es)`);
        if (this.scene && typeof this.scene.lose === "function") {
          this.scene.lose(
            `Kh√¥ng th·ªÉ ƒë·∫∑t ${count} h·ªôp (v∆∞·ª£t qu√° s·ªë ƒëang mang ho·∫∑c √¥ tr∆∞·ªõc m·∫∑t kh√¥ng h·ª£p l·ªá).`
          );
        }
        return false;
      }

      console.log(`‚úÖ Successfully put ${count} box(es)`);
      return true;
    } catch (error) {
      console.error(`‚ùå Error putting boxes:`, error);
      return false;
    }
  }

  /**
   * Th·ª±c thi l·ªánh takeBox
   * @param {number} count - S·ªë l∆∞·ª£ng box c·∫ßn l·∫•y
   * @returns {boolean} Success/failure
   */
  executeTakeBox(count) {
    console.log(`üì¶ Taking ${count} box(es)`);

    try {
      const success = this.scene.takeBox(count);
      if (!success) {
        console.error(`‚ùå Failed to take ${count} box(es)`);
        if (this.scene && typeof this.scene.lose === "function") {
          this.scene.lose(
            `Kh√¥ng th·ªÉ l·∫•y ${count} h·ªôp (kh√¥ng ƒë·ªß h·ªôp t·∫°i √¥ tr∆∞·ªõc m·∫∑t).`
          );
        }
        return false;
      }

      console.log(`‚úÖ Successfully took ${count} box(es)`);
      return true;
    } catch (error) {
      console.error(`‚ùå Error taking boxes:`, error);
      return false;
    }
  }

  /**
   * Th·ª±c thi l·ªánh checkWarehouse
   * @returns {number} S·ªë l∆∞·ª£ng box c√≤n l·∫°i t·∫°i warehouse
   */
  executeCheckWarehouse() {
    console.log(`üè≠ Checking warehouse...`);

    try {
      const remainingBoxes = this.scene.boxManager.checkWarehouse();
      console.log(`üè≠ Warehouse has ${remainingBoxes} boxes remaining`);
      return remainingBoxes;
    } catch (error) {
      console.error(`‚ùå Error checking warehouse:`, error);
      return 0;
    }
  }

  /**
   * L·∫•y tr·∫°ng th√°i hi·ªán t·∫°i
   * @returns {Object} Current state
   */
  getStatus() {
    return {
      isRunning: this.isRunning,
      isPaused: this.isPaused,
      currentStep: this.currentStep,
      totalSteps: this.program ? this.program.actions.length : 0,
      programName: this.program ? this.program.programName : null,
    };
  }
}

import Phaser from "phaser";

/**
 * MapLoader - Utility class ƒë·ªÉ load map v√† objects t√°i s·ª≠ d·ª•ng
 */
export class MapLoader {
  /**
   * Load tilemap v·ªõi c·∫•u h√¨nh chu·∫©n
   * @param {Phaser.Scene} scene - Scene hi·ªán t·∫°i
   * @param {Object} config - C·∫•u h√¨nh load map
   * @param {Object} mapJsonData - Map JSON data t·ª´ webview
   * @returns {Object} Map data v·ªõi map, layer, scale
   */
  static loadMap(scene, config = {}, mapJsonData = null) {
    const {
      offsetX = 300,
      offsetY = 0,
      scale = 1,
      backgroundColor = 0xf3f5f2,
    } = config;

    // Set background
    scene.cameras.main.setBackgroundColor(backgroundColor);
    scene.cameras.main.roundPixels = true;

    // Create tilemap
    let map;
    let layerName = "background";
    if (mapJsonData) {
      // S·ª≠ d·ª•ng mapJsonData t·ª´ webview (Tiled JSON)
      let parsed = mapJsonData;
      if (typeof parsed === "string") {
        try {
          parsed = JSON.parse(parsed);
        } catch (e) {
          console.error(
            "‚ùå MapLoader.loadMap: Failed to parse mapJsonData string:",
            e
          );
        }
      }

      // L·∫•y t√™n tilelayer ƒë·∫ßu ti√™n t·ª´ d·ªØ li·ªáu nh·∫≠n ƒë∆∞·ª£c
      if (parsed && Array.isArray(parsed.layers)) {
        const firstTileLayer = parsed.layers.find(
          (l) => l && l.type === "tilelayer"
        );
        if (firstTileLayer && firstTileLayer.name) {
          layerName = firstTileLayer.name;
        }
      }

      try {
        const dynamicKey = `webview_map_${Date.now()}`;
        // M·ªôt s·ªë b·∫£n build c√≥ th·ªÉ kh√¥ng expose Phaser.Tilemaps.Formats ‚Üí d√πng h·∫±ng s·ªë 1
        const TILEMAP_TILED_JSON =
          (Phaser &&
            Phaser.Tilemaps &&
            Phaser.Tilemaps.Formats &&
            Phaser.Tilemaps.Formats.TILEMAP_TILED_JSON) ||
          1;
        scene.cache.tilemap.add(dynamicKey, {
          data: parsed,
          format: TILEMAP_TILED_JSON,
        });
        map = scene.make.tilemap({ key: dynamicKey });
      } catch (e) {
        console.error(
          "‚ùå MapLoader.loadMap: Failed to create tilemap from parsed data:",
          e
        );
      }
    } else {
      // S·ª≠ d·ª•ng file map.json m·∫∑c ƒë·ªãnh (ƒë√£ preload v·ªõi key 'default')
      try {
        map = scene.make.tilemap({ key: "default" });
      } catch (e) {
        console.error(
          "‚ùå MapLoader.loadMap: No map data found for key 'default'",
          e
        );
      }
    }

    if (!map) {
      throw new Error("Tilemap not created from provided mapJson data");
    }

    // Add tilesets (ph√π h·ª£p v·ªõi demo1.json t·ª´ Tiled)
    const tilesets = [
      map.addTilesetImage("wood", "wood"),
      map.addTilesetImage("road_h", "road_h"),
      map.addTilesetImage("road_v", "road_v"),
      map.addTilesetImage("water", "water"),
      map.addTilesetImage("grass", "grass"),
      map.addTilesetImage("crossroad", "crossroad"),
    ];

    // Create layer v·ªõi offset (s·ª≠ d·ª•ng t√™n layer t·ª´ Tiled)
    // N·∫øu layerName hi·ªán t·∫°i kh√¥ng t·ªìn t·∫°i trong map, ch·ªçn layer tile ƒë·∫ßu ti√™n kh·∫£ d·ª•ng
    let resolvedLayerName = layerName;
    try {
      if (typeof map.getLayerIndex === "function") {
        const idx = map.getLayerIndex(resolvedLayerName);
        if (idx === -1) {
          const names =
            typeof map.getLayerNames === "function" ? map.getLayerNames() : [];
          if (Array.isArray(names) && names.length > 0) {
            resolvedLayerName = names[0];
          } else if (Array.isArray(map.layers) && map.layers.length > 0) {
            resolvedLayerName = map.layers[0].name || resolvedLayerName;
          }
          console.warn(
            `‚ö†Ô∏è Layer '${layerName}' not found. Using '${resolvedLayerName}' instead.`
          );
        }
      }
    } catch {}

    const layer = map.createLayer(
      resolvedLayerName,
      tilesets,
      offsetX,
      offsetY
    );
    layer.setScale(scale);

    return {
      map,
      layer,
      scale,
      offsetX,
      offsetY,
    };
  }

  /**
   * Load objects t·ª´ object layer ho·∫∑c custom data
   * @param {Phaser.Scene} scene - Scene hi·ªán t·∫°i
   * @param {Object} mapData - Data t·ª´ loadMap()
   * @param {Object} objectConfig - C·∫•u h√¨nh objects
   * @returns {Object} Loaded objects
   */
  static loadObjects(scene, mapData, objectConfig) {
    const { map, layer, scale } = mapData;
    const loadedObjects = {
      robot: null,
      batteries: [],
      boxes: [],
      others: [],
    };

    console.log(`üì¶ MapLoader: Starting to load objects`);

    // Load t·ª´ object layer n·∫øu c√≥
    const objectLayer = map.getObjectLayer("objects");
    if (objectLayer) {
      objectLayer.objects.forEach((obj) => {
        const worldPos = this.convertObjectToWorld(obj, mapData);
        const loadedObj = this.createObjectFromTiled(
          scene,
          obj,
          worldPos,
          scale
        );

        if (loadedObj) {
          this.categorizeObject(loadedObj, obj, loadedObjects);
        }
      });
    }

    // Load t·ª´ custom config
    if (objectConfig) {
      this.loadCustomObjects(scene, mapData, objectConfig, loadedObjects);
    }

    console.log(
      `üì¶ MapLoader: Final loaded objects - boxes: ${loadedObjects.boxes.length}`
    );
    return loadedObjects;
  }

  /**
   * Chuy·ªÉn ƒë·ªïi t·ªça ƒë·ªô object t·ª´ Tiled sang world position
   */
  // static convertObjectToWorld(obj, mapData) {
  //   const { map, layer, offsetX, offsetY } = mapData;

  //   // Convert t·ª´ pixel projected sang tile coords
  //   const tileX = obj.x / map.tileWidth;
  //   const tileY = obj.y / map.tileHeight;

  //   // S·ª≠ d·ª•ng map.tileToWorldXY ƒë·ªÉ tr√°nh double offset
  //   const worldPoint = map.tileToWorldXY(tileX, tileY);

  //   // √Åp d·ª•ng offset c·ªßa layer
  //   const finalX = worldPoint.x + offsetX;
  //   const finalY = worldPoint.y + offsetY;

  //   return { x: finalX, y: finalY };
  // }

  /**
   * T·∫°o object t·ª´ Tiled object
   */
  // static createObjectFromTiled(scene, tiledObj, worldPos, scale) {
  //   let spriteKey = null;
  //   let origin = { x: 0.5, y: 1 }; // Default isometric origin

  //   // X√°c ƒë·ªãnh sprite key d·ª±a tr√™n t√™n object
  //   switch (tiledObj.name) {
  //     case "RobotPoint":
  //       spriteKey = "robot_east";
  //       break;
  //     case "PinPoint":
  //     case "BatteryPoint":
  //       spriteKey = "pin_green"; // Default to green pin
  //       break;
  //     case "BoxPoint":
  //       spriteKey = "box";
  //       break;
  //     default:
  //       return null; // Unknown object type
  //   }

  //   // T·∫°o sprite
  //   const sprite = scene.add.image(worldPos.x, worldPos.y, spriteKey);
  //   sprite.setOrigin(origin.x, origin.y);
  //   sprite.setScale(scale);

  //   return {
  //     sprite,
  //     type: tiledObj.name,
  //     originalData: tiledObj,
  //   };
  // }

  /**
   * Ph√¢n lo·∫°i object v√†o categories
   */
  // static categorizeObject(loadedObj, tiledObj, loadedObjects) {
  //   switch (tiledObj.name) {
  //     case "RobotPoint":
  //       loadedObjects.robot = loadedObj.sprite;
  //       break;
  //     case "PinPoint":
  //     case "BatteryPoint":
  //       loadedObjects.batteries.push(loadedObj.sprite);
  //       break;
  //     case "BoxPoint":
  //       if (!loadedObjects.boxes) loadedObjects.boxes = [];
  //       loadedObjects.boxes.push(loadedObj.sprite);
  //       break;
  //     default:
  //       loadedObjects.others.push(loadedObj);
  //       break;
  //   }
  // }

  /**
   * Load objects t·ª´ custom configuration
   */
  static loadCustomObjects(scene, mapData, objectConfig, loadedObjects) {
    const { map, layer, scale } = mapData;

    // Load robot t·ª´ config
    if (objectConfig.robot) {
      const robotConfig = objectConfig.robot;
      let robotPos;

      if (robotConfig.tile) {
        // ƒê·∫∑t robot tr√™n tile c·ª• th·ªÉ
        robotPos = this.getTileWorldCenter(
          robotConfig.tile.x,
          robotConfig.tile.y,
          mapData
        );
      } else if (robotConfig.tileType) {
        // T√¨m tile ƒë·∫ßu ti√™n c·ªßa lo·∫°i n√†y
        robotPos = this.findTileByType(robotConfig.tileType, mapData);
      }

      if (robotPos) {
        // S·ª≠ d·ª•ng robot sprite ph√π h·ª£p v·ªõi h∆∞·ªõng t·ª´ config
        const direction = robotConfig.direction || "east";
        const robotSpriteKey = `robot_${direction}`;

        const robot = scene.add.image(
          robotPos.x,
          robotPos.y + 30,
          robotSpriteKey
        );
        robot.setOrigin(0.5, 1);
        robot.setScale(scale);
        loadedObjects.robot = robot;
      }
    }

    // Load batteries t·ª´ config
    if (objectConfig.batteries) {
      objectConfig.batteries.forEach((batteryConfig) => {
        if (batteryConfig.tileType) {
          // ƒê·∫∑t batteries tr√™n t·∫•t c·∫£ tile c·ªßa lo·∫°i n√†y
          this.placeBatteriesOnTileType(
            scene,
            mapData,
            batteryConfig,
            loadedObjects
          );
        } else if (batteryConfig.tiles) {
          // ƒê·∫∑t batteries tr√™n tiles c·ª• th·ªÉ, h·ªó tr·ª£ count v√† m√†u theo t·ª´ng tile
          batteryConfig.tiles.forEach((tilePos) => {
            const pos = this.getTileWorldCenter(tilePos.x, tilePos.y, mapData);

            const perTileCount =
              (typeof tilePos.count === "number" ? tilePos.count : undefined) ??
              (typeof batteryConfig.count === "number"
                ? batteryConfig.count
                : 1);
            const perTileSpread =
              (typeof tilePos.spread === "number"
                ? tilePos.spread
                : undefined) ??
              (typeof batteryConfig.spread === "number"
                ? batteryConfig.spread
                : 1);

            // Helper l·∫•y type theo index n·∫øu c√≥ m·∫£ng types
            const resolveType = (i) => {
              if (Array.isArray(tilePos.types) && tilePos.types.length > 0) {
                return (
                  tilePos.types[i] || tilePos.types[tilePos.types.length - 1]
                );
              }
              return tilePos.type || batteryConfig.type || "green";
            };

            if (perTileCount <= 1) {
              const batteryType = resolveType(0);
              const batteryKey = `pin_${batteryType}`;
              const battery = scene.add.image(pos.x, pos.y + 10, batteryKey);
              battery.setOrigin(0.5, 1);
              battery.setScale(scale);
              // Depth cao h∆°n robot khi c√πng tile
              battery.setDepth(battery.y + 50);
              loadedObjects.batteries.push(battery);
            } else {
              // ƒê·∫∑t nhi·ªÅu batteries theo h√¨nh tr√≤n quanh t√¢m tile
              const base = Math.min(
                map.tileWidth * layer.scaleX,
                map.tileHeight * layer.scaleY
              );
              const radius = base * 0.2 * perTileSpread;

              for (let i = 0; i < perTileCount; i++) {
                const angle = -Math.PI / 2 + (i * (Math.PI * 2)) / perTileCount;
                const bx = pos.x + radius * Math.cos(angle);
                const by = pos.y + radius * Math.sin(angle);

                const batteryType = resolveType(i);
                const batteryKey = `pin_${batteryType}`;

                const battery = scene.add.image(bx, by + 10, batteryKey);
                battery.setOrigin(0.5, 1);
                battery.setScale(scale);
                // Depth cao h∆°n robot khi c√πng tile
                battery.setDepth(battery.y + 50);
                loadedObjects.batteries.push(battery);
              }
            }
          });
        }
      });
    }

    // Load boxes t·ª´ config
    if (objectConfig.boxes) {
      console.log(
        `üì¶ MapLoader: Loading ${objectConfig.boxes.length} box configs`
      );
      objectConfig.boxes.forEach((boxConfig) => {
        if (boxConfig.tiles) {
          boxConfig.tiles.forEach((tilePos) => {
            const pos = this.getTileWorldCenter(tilePos.x, tilePos.y, mapData);
            const count = tilePos.count || 1;
            const spread = tilePos.spread || 1;

            if (count <= 1) {
              const box = scene.add.image(pos.x, pos.y + 10, "box");
              box.setOrigin(0.5, 1);
              box.setScale(scale);
              loadedObjects.boxes.push(box);
              console.log(
                `üì¶ MapLoader: Created box at (${tilePos.x},${tilePos.y})`
              );
            } else {
              // ƒê·∫∑t nhi·ªÅu boxes theo h√¨nh tr√≤n quanh t√¢m tile
              const base = Math.min(
                map.tileWidth * layer.scaleX,
                map.tileHeight * layer.scaleY
              );
              const radius = base * 0.2 * spread;

              for (let i = 0; i < count; i++) {
                const angle = -Math.PI / 2 + (i * (Math.PI * 2)) / count;
                const bx = pos.x + radius * Math.cos(angle);
                const by = pos.y + radius * Math.sin(angle);

                const box = scene.add.image(bx, by + 10, "box");
                box.setOrigin(0.5, 1);
                box.setScale(scale);
                loadedObjects.boxes.push(box);
              }
              console.log(
                `üì¶ MapLoader: Created ${count} boxes at (${tilePos.x},${tilePos.y})`
              );
            }
          });
        }
      });
    }

    console.log(
      `üì¶ MapLoader: Total boxes loaded: ${loadedObjects.boxes.length}`
    );
  }

  /**
   * L·∫•y world center c·ªßa m·ªôt tile
   */
  static getTileWorldCenter(tileX, tileY, mapData) {
    const { map, layer } = mapData;
    const worldPoint = layer.tileToWorldXY(tileX, tileY);
    const centerX = worldPoint.x + (map.tileWidth * layer.scaleX) / 2;
    const centerY = worldPoint.y + (map.tileHeight * layer.scaleY) / 2;
    return { x: centerX, y: centerY };
  }

  /**
   * T√¨m tile ƒë·∫ßu ti√™n c·ªßa m·ªôt lo·∫°i
   */
  static findTileByType(tileType, mapData) {
    const { map, layer } = mapData;

    // T√¨m tileset theo t√™n
    const tileset = map.tilesets.find((ts) => ts.name === tileType);
    if (!tileset) return null;

    const tileIndex = tileset.firstgid;
    const targetTile = layer.findTile((tile) => tile.index === tileIndex);

    if (targetTile) {
      return this.getTileWorldCenter(targetTile.x, targetTile.y, mapData);
    }

    return null;
  }

  /**
   * ƒê·∫∑t batteries tr√™n t·∫•t c·∫£ tile c·ªßa m·ªôt lo·∫°i
   */
  static placeBatteriesOnTileType(
    scene,
    mapData,
    batteryConfig,
    loadedObjects
  ) {
    const { map, layer, scale } = mapData;
    const { tileType, count = 1, spread = 1 } = batteryConfig;

    // T√¨m tileset
    const tileset = map.tilesets.find((ts) => ts.name === tileType);
    if (!tileset) return;

    const tileIndex = tileset.firstgid;

    // ƒê·∫∑t batteries tr√™n t·∫•t c·∫£ tile c·ªßa lo·∫°i n√†y
    layer.forEachTile((tile) => {
      if (tile.index === tileIndex) {
        const centerPos = this.getTileWorldCenter(tile.x, tile.y, mapData);

        if (count <= 1) {
          // X√°c ƒë·ªãnh lo·∫°i battery (t·ª´ config ho·∫∑c m·∫∑c ƒë·ªãnh)
          const batteryType = batteryConfig.type || "green";
          const batteryKey = `pin_${batteryType}`;

          const battery = scene.add.image(
            centerPos.x,
            centerPos.y + 10,
            batteryKey
          );
          battery.setOrigin(0.5, 1);
          battery.setScale(scale);
          loadedObjects.batteries.push(battery);
        } else {
          // ƒê·∫∑t nhi·ªÅu batteries theo h√¨nh tr√≤n
          const base = Math.min(
            map.tileWidth * layer.scaleX,
            map.tileHeight * layer.scaleY
          );
          const radius = base * 0.2 * spread;

          for (let i = 0; i < count; i++) {
            const angle = -Math.PI / 2 + (i * (Math.PI * 2)) / count;
            const bx = centerPos.x + radius * Math.cos(angle);
            const by = centerPos.y + radius * Math.sin(angle);

            // X√°c ƒë·ªãnh lo·∫°i battery cho multiple batteries
            const batteryType = batteryConfig.type || "green";
            const batteryKey = `pin_${batteryType}`;

            const battery = scene.add.image(bx, by + 10, batteryKey);
            battery.setOrigin(0.5, 1);
            battery.setScale(scale);
            loadedObjects.batteries.push(battery);
          }
        }
      }
    });
  }
}
